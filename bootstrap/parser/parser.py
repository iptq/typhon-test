import pickle
from tokens import *

table = pickle.loads(b'\x80\x03}q\x00(K\x00}q\x01(X\x07\x00\x00\x00Booleanq\x02X\x02\x00\x00\x0011q\x03X\x01\x00\x00\x00{q\x04X\x02\x00\x00\x00s1q\x05X\x05\x00\x00\x00Arrayq\x06X\x02\x00\x00\x0012q\x07X\x06\x00\x00\x00Numberq\x08X\x02\x00\x00\x0013q\tX\x06\x00\x00\x00Stringq\nX\x02\x00\x00\x0014q\x0bX\x05\x00\x00\x00falseq\x0cX\x03\x00\x00\x00s15q\rX\x06\x00\x00\x00Objectq\x0eX\x02\x00\x00\x0016q\x0fX\x03\x00\x00\x00Strq\x10X\x03\x00\x00\x00s17q\x11X\x04\x00\x00\x00trueq\x12X\x03\x00\x00\x00s18q\x13X\x05\x00\x00\x00Valueq\x14X\x02\x00\x00\x0019q\x15X\x03\x00\x00\x00Numq\x16X\x03\x00\x00\x00s20q\x17X\x04\x00\x00\x00Textq\x18X\x02\x00\x00\x0021q\x19X\x01\x00\x00\x00[q\x1aX\x02\x00\x00\x00s2q\x1bX\x04\x00\x00\x00nullq\x1cX\x03\x00\x00\x00s22q\x1dX\x04\x00\x00\x00Nullq\x1eX\x02\x00\x00\x0023q\x1fuK\x01}q (h\nX\x01\x00\x00\x003q!X\n\x00\x00\x00MemberListq"X\x01\x00\x00\x004q#X\x01\x00\x00\x00}q$X\x03\x00\x00\x00s24q%X\x06\x00\x00\x00Memberq&X\x02\x00\x00\x0025q\'h\x10X\x03\x00\x00\x00s17q(uK\x02}q)(h\x02X\x02\x00\x00\x0011q*h\x04X\x02\x00\x00\x00s1q+h\x16X\x03\x00\x00\x00s20q,h\x06X\x02\x00\x00\x0012q-h\x08X\x02\x00\x00\x0013q.h\nX\x02\x00\x00\x0014q/h\x0cX\x03\x00\x00\x00s15q0h\x0eX\x02\x00\x00\x0016q1h\x10X\x03\x00\x00\x00s17q2X\x01\x00\x00\x00]q3X\x03\x00\x00\x00s27q4h\x14X\x02\x00\x00\x0028q5X\x0b\x00\x00\x00ElementListq6X\x01\x00\x00\x009q7h\x12X\x03\x00\x00\x00s18q8h\x1aX\x02\x00\x00\x00s2q9h\x1cX\x03\x00\x00\x00s22q:h\x1eX\x02\x00\x00\x0023q;uK\x03}q<X\x01\x00\x00\x00:q=X\x02\x00\x00\x00s5q>sK\x04}q?(X\x01\x00\x00\x00,q@X\x03\x00\x00\x00s10qAh$X\x03\x00\x00\x00s31qBuK\x05}qC(h\x02X\x02\x00\x00\x0011qDh\x04X\x02\x00\x00\x00s1qEh\x06X\x02\x00\x00\x0012qFh\x08X\x02\x00\x00\x0013qGh\nX\x02\x00\x00\x0014qHh\x0cX\x03\x00\x00\x00s15qIh\x0eX\x02\x00\x00\x0016qJh\x10X\x03\x00\x00\x00s17qKh\x12X\x03\x00\x00\x00s18qLh\x14X\x02\x00\x00\x0026qMh\x16X\x03\x00\x00\x00s20qNh\x1aX\x02\x00\x00\x00s6qOh\x1cX\x03\x00\x00\x00s22qPh\x1eX\x02\x00\x00\x0023qQuK\x06}qR(h\x02X\x02\x00\x00\x0011qSh\x04X\x02\x00\x00\x00s1qTh\x16X\x03\x00\x00\x00s20qUh\x06X\x02\x00\x00\x0012qVh\x08X\x02\x00\x00\x0013qWh\nX\x02\x00\x00\x0014qXh\x0cX\x03\x00\x00\x00s15qYh\x0eX\x02\x00\x00\x0016qZh\x10X\x03\x00\x00\x00s17q[h3X\x03\x00\x00\x00s27q\\h\x14X\x02\x00\x00\x0028q]h6X\x01\x00\x00\x007q^h\x12X\x03\x00\x00\x00s18q_h\x1aX\x02\x00\x00\x00s2q`h\x1cX\x03\x00\x00\x00s22qah\x1eX\x02\x00\x00\x0023qbuK\x07}qc(h@X\x02\x00\x00\x00s8qdh3X\x03\x00\x00\x00s29qeuK\x08}qf(h\x02X\x02\x00\x00\x0011qgh\x04X\x02\x00\x00\x00s1qhh\x06X\x02\x00\x00\x0012qih\x08X\x02\x00\x00\x0013qjh\nX\x02\x00\x00\x0014qkh\x0cX\x03\x00\x00\x00s15qlh\x0eX\x02\x00\x00\x0016qmh\x10X\x03\x00\x00\x00s17qnh\x12X\x03\x00\x00\x00s18qoh\x14X\x02\x00\x00\x0030qph\x16X\x03\x00\x00\x00s20qqh\x1aX\x02\x00\x00\x00s6qrh\x1cX\x03\x00\x00\x00s22qsh\x1eX\x02\x00\x00\x0023qtuK\t}qu(h@X\x02\x00\x00\x00s8qvh3X\x03\x00\x00\x00s29qwuK\n}qx(h&X\x02\x00\x00\x0032qyh\nh!h\x10X\x03\x00\x00\x00s17qzuK\x0b}q{K\x0c}q|K\r}q}K\x0e}q~K\x0f}q\x7fK\x10}q\x80K\x11}q\x81K\x12}q\x82K\x13}q\x83K\x14}q\x84K\x15}q\x85X\x03\x00\x00\x00EOFq\x86X\x03\x00\x00\x00accq\x87sK\x16}q\x88K\x17}q\x89K\x18}q\x8aK\x19}q\x8bh\x04X\x02\x00\x00\x00r8q\x8csK\x1a}q\x8dh\x10X\x02\x00\x00\x00r7q\x8esK\x1b}q\x8fh\x10X\x02\x00\x00\x00r1q\x90sK\x1c}q\x91h\x1aX\x02\x00\x00\x00r5q\x92sK\x1d}q\x93h\x1aX\x02\x00\x00\x00r2q\x94sK\x1e}q\x95(h\x10X\x02\x00\x00\x00r6q\x96h\x12X\x02\x00\x00\x00r6q\x97h\x16X\x02\x00\x00\x00r6q\x98h\x04X\x02\x00\x00\x00r6q\x99h\x0cX\x02\x00\x00\x00r6q\x9ah\x1aX\x02\x00\x00\x00r6q\x9bh\x1cX\x02\x00\x00\x00r6q\x9cuK\x1f}q\x9dh\x04X\x03\x00\x00\x00r13q\x9esK }q\x9fh\x10X\x02\x00\x00\x00r9q\xa0su.')

def get_column(token):
    if type(token) is TSymbol:
        return token.char
    elif type(token) is TString:
        return "Str"

def parse_from_tokens(lexer):
    stack = [0]
    token = lexer.next()

    shifted_token = None
    while True:
        if token is None:
            raise Exception("unexpected end of input")
        if type(token) is TNEWLINE:
            token = lexer.next()
            continue
        state = stack[-1]
        column = get_column(token)
        state = table.get(state)
        if column not in state:
            print(state.keys())
            raise Exception("unexpected token {} (column = {})".format(token, column))
        
        entry = state[column]
        if entry[0] == "s":
            stack.append(token)
            stack.append(int(entry[1:]))
            shifted_token = token
            token = lexer.next()
        print(stack)